/*
 * Acacia - GS-FLX & Titanium read error-correction and de-replication software.
 * Copyright (C) <2011>  <Lauren Bragg and Glenn Stone - CSIRO CMIS & University of Queensland>
 * 
 * 	This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package pyromaniac.DataStructures;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;

public class Pyrotag 
{
	//this class may become more efficient later, for now it will just hold
	//the sequence as characters, and the qualities as an int array
	private String id;
	private int [] qualities;
	private double avgQuality;
	private char [] nucleotides;
	private String desc;
	private MID mid;
	private int numAmbiguousBases;
	private int multiplexTagLength;
	private int trimToLength;
	private int internalID;
	
	public static final HashMap <Character, Character> flowCycle = new HashMap <Character, Character> ();
	public static final Character CYCLE_START = 'T';
	
	static
	{
		flowCycle.put('T', 'A');
		flowCycle.put('A', 'C');
		flowCycle.put('C', 'G');
		flowCycle.put('G', 'T');
	}
	
	public static final int NO_TRIM = -1;
	public static final int NO_TAG = -1;
	public static final int NO_QUALS = -1;

	
	
	public Pyrotag(String id, String desc, Sequence <Character> nucleotideSeq, Sequence <Integer> qualitySeq)
	{
		this.id = id;
		this.desc = desc;
		this.numAmbiguousBases = 0;
		
		assert(nucleotideSeq != null);
		
		this.nucleotides = new char [nucleotideSeq.length()];
		
		for(int i = 0; i < nucleotideSeq.length(); i++)
		{
			this.nucleotides[i] = nucleotideSeq.getValueAtIndex(i);
			
			if(this.nucleotides[i] == 'N')
			{
				this.numAmbiguousBases++;
			}
		}
			
		this.qualities = null;
		this.avgQuality = NO_QUALS;
		
		if(qualitySeq != null)
		{
			this.qualities = new int [qualitySeq.length()];
		
			for(int i = 0; i < qualitySeq.length(); i++)
			{
				this.qualities[i] = qualitySeq.getValueAtIndex(i);
				this.avgQuality += this.qualities[i];
			}
		}
		
		if(qualitySeq != null)
			this.avgQuality = this.avgQuality / this.qualities.length;
		this.mid = null;
		this.trimToLength = NO_TRIM;
		this.multiplexTagLength = NO_TAG;
	}
	
	public double getUntrimmedAvgQuality()
	{
		return this.avgQuality;
	}
	
	public void setInternalID(int id)
	{
		this.internalID = id;
	}
	
	public int getInternalID()
	{
		return this.internalID;
	}
	
	public void setMultiplexTag(MID mid)
	{
		this.mid = mid;
		this.setMultiplexTagLength(mid.MID.length());
	}
	
	
	//flows from zero.
	//assume you want first position after key, and MID, if present.
	public int getFlowForCollapsedReadPos(String key, int nucPos)
	{
		int pos = flowsBetweenLastFlowAndSeqStart(Pyrotag.CYCLE_START, key);
		char prev = key.charAt(0);
		
		for(int i = 1; i < key.length(); i++)
		{
			char curr = key.charAt(i);
			while(flowCycle.get(prev) != curr)
			{
				pos++;
				prev = flowCycle.get(prev);
			}
			pos++; //think this needs to be done anyhow?
		}
		
		char curr;
		char [] collapsed = this.getCollapsedRead(); //doesn't have the MID in it.
		
		//MID
		if(this.mid != null && this.mid.MID.length() > 0)
		{
			pos += flowsBetweenLastFlowAndSeqStart(key.charAt(key.length() - 1), mid.MID);
			curr = this.mid.getMID().charAt(this.mid.getMID().length() - 1); //last character
		}
		else
		{
			curr = key.charAt(key.length() - 1);
		}
		
		//gap between key (or MID) and nucleotide position
		do
		{
			curr = flowCycle.get(curr);
			pos++;
		}
		while(curr != collapsed[0]);
		
		for(int i= 0; i <= nucPos; i++)
		{
			while(curr != collapsed[i])
			{
				pos++;
				curr = flowCycle.get(curr);
			}
		}
		return pos;
	}
	
	public int flowsBetweenLastFlowAndSeqStart(Character lastFlow, String seq)
	{
		return flowsBetweenLastFlowAndChar(lastFlow, seq.charAt(0));
	}
	
	
	public int flowsBetweenLastFlowAndChar(Character lastFlow, Character start)
	{
		Character curr = lastFlow;
		Character seqFirst = start;
		
		int offset = 0;
	
		try
		{
			while(! curr.equals(seqFirst))
			{
				if(seqFirst == null || !flowCycle.containsKey(seqFirst.charValue()))
				{
					throw new Exception("Illegal character in sequence: " + seqFirst.charValue());
				}
			
				curr = flowCycle.get(curr);
				
				if(curr == null)
				{
					throw new Exception("Curr was null: " + seqFirst.charValue());
				}
				
				offset++;
			}
		}
		catch(Exception e)
		{
			e.printStackTrace();
			System.out.println(e.getMessage());
			System.exit(1);
		}
		
		return offset;
	}
	
	private int flowsBetweenSeqStartAndSeqEnd(String seq)
	{
		int flowOffset = 0;
		int seqIndex = 0;
		
		Character prev = seq.charAt(seqIndex);
		seqIndex++;
		
		while(seqIndex < seq.length())
		{
			Character curr = seq.charAt(seqIndex);
			while(!prev.equals(curr))
			{
				prev = flowCycle.get(prev); 
				flowOffset++;
			}
			seqIndex++;
		}
		return flowOffset;
	}
	
	
	private void setMultiplexTagLength(int length)
	{
		this.multiplexTagLength = length;
	}
	
	public void setEndTrim(int trimToLength)
	{
		this.trimToLength = trimToLength;
	}
	
	public int getNumAmbiguousBases() 
	{
		return numAmbiguousBases;
	}
	
	public String getDescription()
	{
		return this.desc;
	}

	public int [] getQualities()
	{
		return this.qualities;
	}
	
	public void trimUsingMinQuality(int minQuality)
	{
		//will set the trimLength..
	}
	
	public char [] getTag()
	{
		if(this.multiplexTagLength != NO_TAG)
		{
			char [] tag = new char [this.multiplexTagLength];
			
			for(int i = 0; i < tag.length; i++)
			{
				tag[i] = this.nucleotides[i];
			}
			
			return tag;
		}
		return null;
	}
	
	
	public char getBase(int index)
	{
		assert(index < nucleotides.length);
		return nucleotides[index];
	}
	
	public int getLength()
	{
		return this.nucleotides.length;
	}
	
	public int getQuality(int index)
	{
		assert(index < qualities.length);
		return qualities[index];
	}
	
	public char [] getReadString()
	{
		return this.nucleotides;
	}
	
	public char [] getProcessedString()
	{
		char [] processed;
		
		if(this.trimToLength == NO_TRIM && this.multiplexTagLength == NO_TAG)
		{
			processed = new char [this.nucleotides.length];
			
			for(int i = 0; i < processed.length; i++)
			{
				processed[i] = Character.toUpperCase(this.nucleotides[i]);
			}
			return processed;
		}

		int start = (this.multiplexTagLength == NO_TAG)? 0 : this.multiplexTagLength;		
		int end = (this.trimToLength == NO_TRIM) ? this.nucleotides.length: ((this.trimToLength + start < this.nucleotides.length) ? this.trimToLength + start : this.nucleotides.length);
			
		char [] processedString = new char [end - start];
		
		for(int i = start; i < end; i++)
		{
			processedString[i - start] = Character.toUpperCase(this.nucleotides[i]);
		}
		
		return processedString;
	}
	
	
	public String toString()
	{
		StringBuffer sb = new StringBuffer();
		int width = 20;
		
		sb.append(this.id + " " + this.desc);
		sb.append(System.getProperty("line.separator"));
		for(int i = 0; (i + width) < nucleotides.length; i+= width)
		{
			sb.append(nucleotides, i, width);
			sb.append(System.getProperty("line.separator"));
			
			if(qualities != null)
			{
				for(int j = i; j < (i + width); j++)
				{
					sb.append(qualities[j]);
					if(j + 1 < (i + width))
					{
						sb.append(" ");
					}
				}
				sb.append(System.getProperty("line.separator"));	
			}
			
			if(i + width > nucleotides.length)
			{
				width = nucleotides.length - i;
			}
		}
		return sb.toString();
	}

	public String getID() 
	{
		return this.id;
	}

	public boolean hasNs()
	{
		for(int i = 0; i < this.nucleotides.length; i++)
		{
			if(nucleotides[i] == 'N')
				return true;
		}
		return false;
	}
	
	
	public int getTrimmedAverageQuality() 
	{
			if(this.qualities == null)
			{
				return NO_QUALS;
			}
		
			int posStart = (this.multiplexTagLength == NO_TAG)? 0 : this.multiplexTagLength;
			int posEnd = (this.trimToLength == NO_TRIM)? this.nucleotides.length: this.trimToLength;
			
			int currPos = posStart;
			int sum = 0;
			while(currPos < posEnd)
			{
				sum += this.qualities[currPos];
				currPos++;
			}
			
			int average = (sum / (posEnd - posStart + 1));
			return average;
	}
	
	public int [] toFlowGram(HashMap <Character, Character> flowCycle, char flowStart, int numFlows, String key)
	{
		int [] flowGram = new int [numFlows * 4];
		
		int actualFlowPos = 0;
		char currNucleotide = flowStart;
		
		//assuming the key is not present, dont care about the hp counts or anything.
		for(int i = 0; i < key.length(); i++)
		{
			while(currNucleotide !=  key.charAt(i))
			{
				currNucleotide = flowCycle.get(currNucleotide);
				actualFlowPos++;
			}
		}
		actualFlowPos++; //bring us up to position four.
		currNucleotide = flowCycle.get(currNucleotide);
		
		for(int i = 0; i < flowGram.length; i++)
		{
			flowGram[i] = 0;
		}
		
		//last base was currNucleotide
		
		//similarly
		
		int offset = 0;
		for(int i = 0; i < this.nucleotides.length; i++)
		{	
			while(currNucleotide != this.nucleotides[i])
			{
				offset++;
				currNucleotide = flowCycle.get(currNucleotide);
			}
			
			int j = i + 1;
			
			while(j < this.nucleotides.length && this.nucleotides[j] == this.nucleotides[i])
			{
				j++;
			}
			
			flowGram[offset] = j - i;
			i = j - 1;
		}
		
		int [] flowGramShort = new int [offset];
		
		for(int i = 0; i < flowGramShort.length; i++)
		{
			flowGramShort[i] = flowGram[i];
		}
		
		return flowGramShort;
	}
	
	//MIDoffset is first base afterMID
	public char [] getCollapsedRead()
	{
		char [] collapsed = new char [this.nucleotides.length - this.multiplexTagLength];
		
		int indexCollapsed = 0;
		char prev = 'z';
		
		int maxPos = (this.trimToLength != Pyrotag.NO_TRIM)? this.trimToLength: this.nucleotides.length;
		
		
		for(int i = this.multiplexTagLength; i < maxPos; i++)
		{
			if(prev != this.nucleotides[i])
			{
				collapsed[indexCollapsed] = this.nucleotides[i];
				indexCollapsed++;
			}
			prev = this.nucleotides[i];
		}
		
		return Arrays.copyOf(collapsed, indexCollapsed);
	}
	
	public int getTrimToLength() {
		return trimToLength;
	}

	public void setTrimToLength(int trimToLength) {
		this.trimToLength = trimToLength;
	}

	public MID whichMID(LinkedList <MID> validTags)
	{
		HashMap <MID, Boolean> notMatched = new HashMap <MID, Boolean>();
		int endPos = -1;
		
		for(int i = 0; i < this.nucleotides.length; i++)
		{
			boolean anyThisLong = false;
			
			for(MID midObj: validTags)
			{
				String mid = midObj.MID;
				
				if(mid.length() > i)
				{
					//System.out.println("Comparing MID: " + midObj.descriptor + " at pos " + i + ": " + mid.charAt(i) + " to seq " + this.nucleotides[i]);
					
					if(mid.charAt(i) != this.nucleotides[i])
					{
						notMatched.put(midObj, false);
					}
					else
					{
						anyThisLong = true;
						endPos = i;
					}
				}
			}
			if(! anyThisLong)
				break;
		}
		
		for(MID mid: validTags)
		{
			if(! notMatched.containsKey(mid))
				return mid;
		}
		return null;
	}

	public MID getMultiplexTag() 
	{
		return this.mid;
	}
}
