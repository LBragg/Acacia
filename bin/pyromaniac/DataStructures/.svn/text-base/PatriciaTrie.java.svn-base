
/*
 * Acacia - GS-FLX & Titanium read error-correction and de-replication software.
 * Copyright (C) <2011>  <Lauren Bragg and Glenn Stone - CSIRO CMIS & University of Queensland>
 * 
 * 	This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package pyromaniac.DataStructures;

import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Vector;
public class PatriciaTrie 
{
	private Node head;
	public static final int MAX_CHILDREN = 5;
	public static final char STRING_END = '$';
	public static final HashMap <Character, Integer> baseToArrayPos;
	public static final HashMap <Integer, Character> arrayPosToBase;
	
	static
	{
		//alphabetical order
		baseToArrayPos =  new HashMap <Character, Integer>(17);
		baseToArrayPos.put('$', 0);
		baseToArrayPos.put('A', 1);
		baseToArrayPos.put('C', 2);
		baseToArrayPos.put('G', 3);
		baseToArrayPos.put('T', 4);
		
		arrayPosToBase = new HashMap <Integer, Character>(17);
		arrayPosToBase.put(0, '$');
		arrayPosToBase.put(1, 'A');
		arrayPosToBase.put(2, 'C');
		arrayPosToBase.put(3, 'G');
		arrayPosToBase.put(4, 'T');
	}
	
	public PatriciaTrie()
	{
		this.head = new Node('^');
	}
	
	public void insertString(String value, Pyrotag p)
	{
		this.head.insertSeq(value, 0, p);
	}
	
	
	/*
	public static void main (String [] args)
	{
		
		PatriciaTrie trie = new PatriciaTrie();
		
		trie.insertString("ATGC", "1");
		trie.insertString("ATG", "2");
		trie.insertString("ACGG", "3"); //correct
		trie.insertString("ATGA", "4");
		
		LinkedList <HashSet <String>> prefixSet = trie.getPrefixSets();
		
		for(HashSet <String> ids : prefixSet)
		{
			System.out.println("Cluster: " + System.getProperty("line.separator"));
			for(String id : ids)
			{
				System.out.println("ID: " + id);
			}
		}
	}
	*/
	
	
	public LinkedList <Pair <HashSet <Pyrotag>, String>> getPrefixSets()
	{
		ArrayDeque <Pair<Node, HashSet <Pyrotag>>> queue = new ArrayDeque<Pair <Node, HashSet <Pyrotag>>>();
		queue.addFirst(new Pair <Node, HashSet <Pyrotag>> (this.head, new HashSet <Pyrotag>()));
		
		LinkedList <Pair <HashSet <Pyrotag>,  String>> sharedPrefixSets = new LinkedList <Pair <HashSet <Pyrotag>, String>> ();
		
		while(queue.size() > 0)
		{
			Pair <Node, HashSet <Pyrotag>> pairToProcess = queue.pop();
			
			Node noValue = pairToProcess.getFirst().getChild(STRING_END);
			
			boolean finishedPath = true;
			for(int i = 0; i < PatriciaTrie.MAX_CHILDREN; i++)
			{
				
				char currChild = arrayPosToBase.get(i); 
				if(currChild != STRING_END && pairToProcess.getFirst().getChild(currChild) != null)
				{
					finishedPath = false;
					
					
					HashSet <Pyrotag> clone = new HashSet <Pyrotag>();
					clone.addAll(pairToProcess.getSecond());
					
					if(noValue != null)
					{
						clone.addAll(noValue.getTags());
					}
					
					queue.push(new Pair <Node, HashSet <Pyrotag>>(pairToProcess.getFirst().getChild(currChild),clone));
				}
			}
			
			if(finishedPath)
			{
				if(noValue != null)
				{
					pairToProcess.getSecond().addAll(noValue.getTags());
				}
				
				Pyrotag rep = pairToProcess.getSecond().iterator().next(); //the longest sequences shall be the rep.
				String repSeq = new String(rep.getCollapsedRead());
				sharedPrefixSets.push(new Pair <HashSet <Pyrotag>, String>(pairToProcess.getSecond(), repSeq));
			}
		}
		
		return sharedPrefixSets;
	}
	
	



	class Node
	{
		private char value;
		private Node [] children;	
		HashSet <Pyrotag> tags;
		
		public Node(char value)
		{
			this.value = value;
			children = null;
			tags = null;
		}
		
		public void addTag(Pyrotag p)
		{
			if(tags == null)
				tags = new HashSet <Pyrotag>();
			
			tags.add(p);
		}
		
		public void deleteTags()
		{
			this.tags = null;
		}
		
		public HashSet <Pyrotag> getTags()
		{
			return this.tags;
		}
		
		public char getValue() 
		{
			return value;
		}
		
		public void setValue(char value) 
		{
			this.value = value;
		}
		
		public Node[] getChildren() 
		{
			return children;
		}
		
		public void setChildren(Node[] children) 
		{
			this.children = children;
		}
		
		public void addChild(Node node)
		{
			if(this.children == null)
				this.children = new Node [PatriciaTrie.MAX_CHILDREN]; 
			
			this.children[baseToArrayPos.get(node.getValue())] = node;
		}
		
		public Node getChild(char value)
		{
			if(this.children == null)
				return null;
			
			return this.children[baseToArrayPos.get(value)];
		}
		
		public void insertSeq(String sequence, int offset, Pyrotag p)
		{
			if(sequence.length() == offset)
			{
				if(this.getChild(STRING_END) == null)
				{
					Node newChild = new Node(STRING_END);
					
					newChild.addTag(p);
					this.addChild(newChild);
				}
				else
				{
					this.getChild(STRING_END).addTag(p);
				}
			}
			else
			{
				char currInSeq = sequence.charAt(offset);
				if(getChild(currInSeq) == null)
				{
					Node newChild = new Node(currInSeq);
					this.addChild(newChild);
					newChild.insertSeq(sequence, offset + 1, p);
				}
				else
				{
					getChild(currInSeq).insertSeq(sequence, offset + 1, p);
				}
			}
		}
	}	
}
