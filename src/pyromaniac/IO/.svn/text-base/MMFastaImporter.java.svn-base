/*
 * Acacia - GS-FLX & Titanium read error-correction and de-replication software.
 * Copyright (C) <2011>  <Lauren Bragg and Glenn Stone - CSIRO CMIS & University of Queensland>
 * 
 * 	This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package pyromaniac.IO;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.CharBuffer;
import java.nio.IntBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CoderResult;
import java.util.ArrayList;

import pyromaniac.DataStructures.MutableInteger;
import pyromaniac.DataStructures.Pyrotag;
import pyromaniac.DataStructures.Sequence;
import pyromaniac.IO.SeqReadingUtility.SeqFormattingException;
import pyromaniac.IO.AcaciaLogger;

public class MMFastaImporter 
{
	private RandomAccessFile ramSeq;
	private RandomAccessFile ramQual;
	private FileChannel fcSeq;
	private FileChannel fcQual;
	private CharBuffer ib;
	private CharBuffer qb;
	private AcaciaLogger logger;
	private String seqFile;
	private String qualFile;
	private int[] seqStarts; //populate these first
	private int [] qualStarts;//populate these first
	public static final char  BEGINNING_FASTA_HEADER = '>';
	public static final String ACCEPTIBLE_IUPAC_CHARS = "ATGCNURYWSMKBHDV";
	
	public MMFastaImporter(String seqFile, String qualFile, AcaciaLogger logger)
	{
		this.seqFile = seqFile;
		this.qualFile = qualFile;
		this.logger = logger;
		
		this.init();
	}
	
	private void init()
	{
		try
		{
			System.out.println("Caliing initSeq");
			_initSeq();
			System.out.println("Calling initQual");
			_initQual();
		    System.out.println("Finished initialising FASTA importer");
		}
		catch(CharacterCodingException cce)
		{
			System.out.println("Error " + cce.getMessage());
			cce.printStackTrace();
		}
		catch(IOException ie)
		{
			System.out.println("Error " + ie.getMessage());
			ie.printStackTrace();
			System.exit(1);
		}
		catch(Exception e)
		{
			System.out.println("An exception occurred " + e.getMessage());
		}
	}
	
	private void _initSeq() throws Exception
	{
		System.out.println("Initialising MMFAStaIMporter");
		
		FileInputStream tempStream = new FileInputStream(new File(this.seqFile)); 
	    fcSeq = tempStream.getChannel();
	    
	    
	    MappedByteBuffer  buff = fcSeq.map(FileChannel.MapMode.READ_ONLY, 0, fcSeq.size());
	    
	    ArrayList <Integer> seqStartsList = new ArrayList <Integer>(); 
	    
	    System.out.println("Before decoding");
	    
	    
	    Charset charset = Charset.forName("US-ASCII"); //decoding?
	    CharsetDecoder decoder = charset.newDecoder();
	     
	      try
	      {
	    	  this.ib = decoder.decode(buff);
	      }
	      catch(Exception e)
	      {
	    	  System.out.println("decoding failed " + e.getMessage());
	      }
	   
	      System.out.println("After decoding");
	      
	    while(ib.hasRemaining())
	    {
	    	char curr = (char)ib.get();
	    	if(curr == BEGINNING_FASTA_HEADER)
	    	{
	    		seqStartsList.add((ib.position()));
	    	}
	    }
	   
	    System.out.println("Before rewinding");
	    ib.rewind();//does this help?
	    
	    fcSeq.close();
	    this.seqStarts = new int [seqStartsList.size()];
	    for(int i = 0; i < this.seqStarts.length;i++)
	    {
	    	this.seqStarts[i] = seqStartsList.get(i);
	    }
	}
	
	
	private void _initQual() throws Exception
	{
	    if(this.qualFile != null && qualFile.trim().length() > 0)
	    {//own scope for now,
			System.out.println("Trying to initalise with qualFiles");

			FileInputStream qualStream = new FileInputStream(new File(this.qualFile)); 
		
		    this.fcQual = qualStream.getChannel();

		    ArrayList <Integer> qualStartsList = new ArrayList <Integer>(); 			
		    
		    System.out.println("File is of size " + fcQual.size());
		    
		    MappedByteBuffer  qbuff = fcQual.map(FileChannel.MapMode.READ_ONLY, 0, fcQual.size());
		    
		    System.out.println("BReak 1");
		    
		    Charset qCharset = Charset.forName("US-ASCII"); //decoding?
		    System.out.println("BReak 1a");
		    CharsetDecoder qDecoder = qCharset.newDecoder();
		    System.out.println("BReak 1b");
		    this.qb = qDecoder.decode(qbuff);

		    System.out.println("BReak 2");
		    
		    while(qb.hasRemaining())
		    {
		    	char curr = (char)qb.get();
		    	if(curr == BEGINNING_FASTA_HEADER)
		    	{
		    		qualStartsList.add((qb.position()));
		    	}
		    }
		    System.out.println("BReak 3");
		    qb.rewind();//does this help?
		    
		    fcQual.close();
		    System.out.println("BReak 4");
		    this.qualStarts = new int [qualStartsList.size()];
		    for(int i = 0; i < this.qualStarts.length;i++)
		    {
		    	this.qualStarts[i] = qualStartsList.get(i);
		    }
		    System.out.println("finished qualfiles");
	    }
	}
	
	
	public Pyrotag getPyrotagAtIndex(int index)
	{
		if(index >= this.seqStarts.length)
			return null;
		
		
		char [] relSeqBlock = getBlock(this.seqStarts, index, this.ib);
		
		//construct the pyrotag in this block.
		Sequence <Character> pyrotagSeq = processSeqBlock(relSeqBlock);
		
		Sequence <Integer> qualitySeq = null;
		
		if(this.qualFile != null)
		{
			char [] relQualBlock = getBlock(this.qualStarts,index, this.qb);
			qualitySeq = processQualBlock(relQualBlock);
		}
		
		Pyrotag p = new Pyrotag(pyrotagSeq.getId(), pyrotagSeq.getDesc(), pyrotagSeq, qualitySeq);
		
		p.setInternalID(index);
		return p;
	}
	
	private char [] getBlock(int [] starts, int index, CharBuffer cb)
	{
		if(index  >= starts.length)
		{
			System.out.println("Returning null");
			return null;
		
		}
		int blockStart = starts[index];
		int blockEnd = blockStart; //nothing...
		
		if(index == starts.length - 1)
			blockEnd = cb.limit();
		else
			blockEnd = starts[index + 1] -1;
		
		char [] relBlock = new char [blockEnd - blockStart + 1]; 
	
		try
		{
			int ctr = 0;
			int abs = blockStart;
			
			while(abs < blockEnd)
			{
				relBlock[ctr] = cb.get(abs);
				abs++;
				ctr++;
			}			
			return relBlock;
		}
		catch(Exception e)
		{
			System.out.println("Error: " + e.getMessage());
			System.out.println("Tried to get block starting at " + blockStart + " for " + (blockEnd - blockStart + 1) + " chars");
			System.out.println("The maximum block size is " + cb.limit());
		}
		return null;
	}
	
	
	
	public Sequence <Character> processSeqBlock(char [] pyrotagBlock)
	{	
		try
		{
			MutableInteger index = new MutableInteger(0);
			String identifier = _readIdentifier(pyrotagBlock,index);
			String [] idComp = parseIdentifierLine(identifier);
			ArrayList <Character> nucleotides = this._readSequence(pyrotagBlock, index);
			
			Sequence <Character> pyrotagSeq = new Sequence<Character> (nucleotides, idComp[0], idComp[1]);
			return pyrotagSeq;
		}
		catch(SeqFormattingException sfe)
		{
			System.out.println(sfe.getMessage());
			System.exit(1);
		}
		return null;
	}
	
	public Sequence <Integer> processQualBlock(char [] qualBlock)
	{
		try
		{
			MutableInteger index = new MutableInteger(0);
			String identifier = _readIdentifier(qualBlock,index);
			String [] idComp = parseIdentifierLine(identifier);
			ArrayList <Integer> qualities = this._readQualities(qualBlock, index);
			
			Sequence <Integer> pyrotagQual = new Sequence<Integer> (qualities, idComp[0], idComp[1]);
			return pyrotagQual;
		}
		catch(SeqFormattingException sfe)
		{
			System.out.println(sfe.getMessage());
			System.exit(1);
		}
		return null;
	}
	
	
	public String _readIdentifier(char [] pyrotagBlock, MutableInteger pos)
	{
		StringBuffer buff = new StringBuffer();
		
		int currPos = pos.value();
		
		char curr = pyrotagBlock[currPos];
		
		while(!(curr == '\n' || curr == '\r'))
		{
			buff.append(curr);
			currPos++;
			curr = pyrotagBlock[currPos];
		}
		
		pos.update(currPos);
		return buff.toString();
	}
	
	
	public int getNumberOfSequences()
	{
		return this.seqStarts.length;
	}
	
	public String [] parseIdentifierLine(String identifierLine)
	{

		int posWhite = identifierLine.indexOf(" ");
		
		String [] IDAndDescription = new String [2];
		if(posWhite > 0)
		{
			IDAndDescription[0] = identifierLine.substring(0, posWhite);
			IDAndDescription[1] = identifierLine.substring(posWhite + 1, identifierLine.length());
		}
		else
		{
			IDAndDescription[0] = identifierLine;
			IDAndDescription[1] = "";
		}
		return IDAndDescription;
	}
	
	public ArrayList <Character> _readSequence(char [] pyrotagBlock, MutableInteger pos) throws SeqFormattingException
	{
			ArrayList <Character> characters = new ArrayList <Character>();			
			
			char curr;
			int index = pos.value();
			
			while(index < pyrotagBlock.length)
			{
				curr = pyrotagBlock[index];
				curr = Character.toUpperCase(curr);
				if(Character.isLetter((char)curr))
				{
					if(ACCEPTIBLE_IUPAC_CHARS.indexOf(curr) == -1)
					{
						throw new SeqFormattingException("Non-IUPAC character (" + curr + ") in sequence", this.seqFile);
					}
					else
					{
						characters.add(curr);
					}
				}
				index++;
			}
			pos.update(index);
			return characters;
	}
	
	public ArrayList <Integer> _readQualities(char [] pyrotagBlock, MutableInteger pos) throws SeqFormattingException
	{
		ArrayList <Integer> qualities = new ArrayList <Integer>();
		
		String currInt = "";
		char curr;
		
		int index = pos.value();
		try
		{
			while(index < pyrotagBlock.length)
			{
				curr = pyrotagBlock[index];

				if(Character.isLetterOrDigit(curr) || Character.isWhitespace(curr))
				{
					if(Character.isLetter(curr))
					{
						throw new SeqFormattingException("Non-numeric quality score encountered: " + curr, this.qualFile);
					}
					else if(Character.isWhitespace(curr) && currInt.length() > 0)
					{
						System.out.println("Curr qual: " + currInt);
						qualities.add(Integer.parseInt(currInt));
						currInt = "";
					}
					else if(Character.isDigit(curr))
					{
						currInt = currInt + curr;
					}
				}
				else  if (currInt.length() > 0)
				{
					qualities.add(Integer.parseInt(currInt));
					currInt = "";
				}
				index++;
			}
			if(currInt.length() > 0)
			{
				qualities.add(Integer.parseInt(currInt));
			}
			return qualities;
		}
		catch(NumberFormatException nfe)
		{
			throw new SeqFormattingException("Quality score: " + currInt + " is not an integer ", this.qualFile);
		}
	}
	
	
	public class SeqFormattingException extends Exception
	{
		private static final long serialVersionUID = 1L;
		public SeqFormattingException(String message, String filename)
		{
			super("File: " + filename  + " FormattingException: " + message);
		}
	}
}
