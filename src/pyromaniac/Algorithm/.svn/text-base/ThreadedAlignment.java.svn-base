/*
 * Acacia - GS-FLX & Titanium read error-correction and de-replication software.
 * Copyright (C) <2011>  <Lauren Bragg and Glenn Stone - CSIRO CMIS & University of Queensland>
 * 
 * 	This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package pyromaniac.Algorithm;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Set;

import pyromaniac.DataStructures.MutableInteger;
import pyromaniac.DataStructures.Pair;
import pyromaniac.DataStructures.Pyrotag;
import pyromaniac.IO.AcaciaLogger;

public class ThreadedAlignment 
{
	private AlignmentColumn head;
	private AcaciaLogger logger;
	
	public ThreadedAlignment(String consensusSeed, AcaciaLogger logger)
	{
		this.head = new AlignmentColumn(' ');
		this.logger = logger;
		
		AlignmentColumn curr = head;
		
		for(int i = 0; i < consensusSeed.length(); i++)
		{
			AlignmentColumn newChild = new AlignmentColumn(consensusSeed.charAt(i));
			newChild.setParent(curr);
			curr.setChild(newChild);
			curr = newChild;
		}
	}
	
	private ThreadedAlignment()
	{
		this.head = null;
	}
	
	
	public ThreadedAlignment cloneAlignmentWithTags(HashSet <Pyrotag> p)
	{
		try
		{
			ThreadedAlignment ta = new ThreadedAlignment();
			ta.head = this.head.cloneRecursivelyWithTags(p,null);
			
			return ta;
		}
		catch(Exception e)
		{
			System.out.println("logger had an exception");
		}
		return null;
	}

	public HashSet<Pyrotag> getAllTags()
	{
		HashSet <Pyrotag> allTags = new HashSet <Pyrotag>();
		if (this.head.child == null)
			return allTags;
		
		//done!
		allTags.addAll(this.head.child.getTags());
		allTags.addAll(this.head.child.getInsertionTags());
		
		return allTags;
	}
	
	public String toString()
	{
		StringBuilder sb = new StringBuilder();
			
		AlignmentColumn curr = this.head;
		while(curr != null)
		{
			sb.append(curr.toString());
			curr = curr.child;
		}
		return sb.toString();
	}
	
	
	public boolean align(Pyrotag p) throws Exception
	{		
		try
		{
			AlignmentColumn nodeBeforeLastMismatch = null;		
			AlignmentColumn curr = this.head.child;
			AlignmentColumn lastDefined = this.head;
			
			boolean verbose = false;
			boolean endOfReference = false;
			
			LinkedList <PendingChange> pendingChanges = new LinkedList <PendingChange>();
			
			char [] value = p.getProcessedString();
			
			/*
			if(verbose)
			{
				System.out.println("Processed string: " + new String(value));
			}
				*/
			
			for(int i = 0; i < value.length; i++)
			{
				char currToken = value[i];
				
	
				
				int startPos = i;
				
				while(i < value.length && currToken == value[i])
				{
					i++;
				}
				
				int hpLength = i - startPos; 
					
				i--; //dont want to go too far forward.
			
				//double check this continue logic, could be whack
				if(endOfReference)
				{
					AlignmentColumn newChild = new AlignmentColumn(currToken);
					newChild.obs.put(p, hpLength);
					newChild.setParent(lastDefined);
					lastDefined.setChild(newChild);
					lastDefined = newChild;
					if(verbose)
					{
						logger.writeLog("Alignment is at end of reference", AcaciaLogger.LOG_DEBUG);
						logger.writeLog("Inserting: " + currToken + " of length " + hpLength, AcaciaLogger.LOG_DEBUG);
					}
					
				}
				else
				{
					//first things first, lets check for identity
					if(currToken == curr.getValue())
					{
						if(verbose)
						{
							logger.writeLog("Perfect identity: " + currToken, AcaciaLogger.LOG_DEBUG);
						}
						pendingChanges.add(new AddObservation(curr, p, hpLength));
						lastDefined = curr;
						curr = curr.child;
					}
					else
					{
						//consecutive mismatches will not be tolerated.
						if(nodeBeforeLastMismatch != null && nodeBeforeLastMismatch == curr.getParent())
						{
							if(verbose)
								logger.writeLog("Two consecutive mismatches", AcaciaLogger.LOG_DEBUG);
							return false; //we will not tolerate TWO consecutive errors, so stick it!
						}
						
						boolean found = false;
						
						//insertion in query
						if(i + 1 < value.length && value[i + 1] == curr.getValue())
						{
							found = true;
							AlignmentColumn grandParent = curr.getParent();
					
							//grand parent is null then TODO: bug
							
							if(grandParent.getInsertionCorrespondingTo(currToken) != null)
							{
								AlignmentColumn insertionNode = grandParent.getInsertionCorrespondingTo(currToken);
								pendingChanges.add(new AddObservation(insertionNode, p, hpLength));
								
								nodeBeforeLastMismatch = grandParent;
								if(verbose)
									logger.writeLog("Setting up as an insertion", AcaciaLogger.LOG_DEBUG);
							}
							else
							{	
								//make an insertion node representing that insertion
								pendingChanges.add(new InsertAChild(this, grandParent, p, currToken, hpLength));
								nodeBeforeLastMismatch = grandParent;
								//curr = curr.getChild();
								if(verbose)
									logger.writeLog("Matches a previously seen insertion", AcaciaLogger.LOG_DEBUG);
							}
						}
						else if(curr.getChild() == null)
						{
							AlignmentColumn newTerminal = new AlignmentColumn(currToken);
							newTerminal.obs.put(p, hpLength);
							endOfReference = true;
							curr.child = newTerminal;
							curr = newTerminal;
							lastDefined = newTerminal;
							if(verbose)
								logger.writeLog("Curr is null", AcaciaLogger.LOG_DEBUG);
						}
						else if(curr.getChild().getValue() == value[i]) //clean deletion in the inserted sequence.
						{
							if(verbose)
							{
								logger.writeLog("Clean deletion", AcaciaLogger.LOG_DEBUG);
								logger.writeLog("Value of curr node is " + curr.getValue(), AcaciaLogger.LOG_DEBUG);
								logger.writeLog("Value of child node is " + curr.getChild().getValue(), AcaciaLogger.LOG_DEBUG);	
							}	
							pendingChanges.add(new AddObservation(curr, p, 0));
							lastDefined = curr;
							curr = curr.getChild();
							i = startPos - 1; //because i gets incremented. //this is wrong, i should go back to its original value
						}
						else
						{
							return false; //something odd happened.
						}
					}
					
					if(curr == null)
					{
						endOfReference = true;
					}
				}
			}
			
			
			
			/*
			if(endOfReference)
			{
				System.out.println("This alignment: " + this.toString());
				
				System.exit(1);
			}
			*/
			
			//if I made it this far, I obviously inserted properly, so execute all the pending changes.
			
			for(PendingChange pc : pendingChanges)
			{
				pc.performModification();
			}
			return true;
		}
		catch(Exception e)
		{
			
		}
		return false;
	}
	
	public Pair <String, HashMap <Pyrotag, MutableInteger >> getLongestConsensus()
	{
		HashMap <Pyrotag, MutableInteger> cleanedTagLength = new HashMap <Pyrotag, MutableInteger>();
		StringBuilder consensus = new StringBuilder();
		AlignmentColumn curr = this.head;
		
		int totalObs = 0; //whats totalObs for?
		boolean verbose = false;
		
		for(Pyrotag p: this.getAllTags())
		{
			if(p.getID().equals("FIQU8OX06G542G"))
			{
				verbose = false;
			}
		}
		
		while(curr != null)
		{
			char value = curr.getValue();
			if(value != ' ')
			{
				//curr = curr char, consensus   is our string builder, and cleaned tag length is our tags + length
				if(verbose)
				{
					System.out.println("Helper for val: " + value);
				}
				
				totalObs += _helperGetLongestConsensus(curr, consensus, cleanedTagLength, verbose);
				
				
				
			}
			
			for(int i = 0; i < curr.insertionsAfter.length; i++)
			{
				if(curr.insertionsAfter[i] != null)
				{
					if(verbose)
					{
						System.out.println("Calling helper for insertion after curr: ");
					}
					totalObs += _helperGetLongestConsensus(curr.insertionsAfter[i], consensus, cleanedTagLength, verbose);
				}
			}
			curr = curr.child;
		}
		
		return new Pair <String, HashMap <Pyrotag, MutableInteger>>(consensus.toString(), cleanedTagLength);
	}
	
	public int _helperGetLongestConsensus(AlignmentColumn curr, StringBuilder consensus, 
			HashMap<Pyrotag, MutableInteger> cleanedTagLength, boolean verbose)
	{
		char value = curr.getValue();
		int nonModeObs =  0;
		
		if(value != ' ')
		{
			int modeObs = -1 ;
			int modeLength = -1;
			
			HashMap <Integer, HashSet <Pyrotag>> hpToTags = curr.getHPLengthToTags();		
			for(Integer length: hpToTags.keySet())
			{
				nonModeObs += hpToTags.get(length).size();	
				
				
				if(hpToTags.get(length).size() > modeObs)
				{					
					modeLength = length;
					modeObs = hpToTags.get(length).size();
				}
			}
						
			//make sure we keep a record of where these sequences line up to .
			for(Integer length: hpToTags.keySet())
			{
				for(Pyrotag p: hpToTags.get(length))
				{
					if(!cleanedTagLength.containsKey(p))
					{
						cleanedTagLength.put(p, new MutableInteger(0));
					}
					else
					{
						cleanedTagLength.get(p).add(modeLength);
					}
				}
			}
			
			for(int i = 0; i < modeLength; i++)
			{
				consensus.append(value);
			}
		}
		
		return nonModeObs;
	}
	
	
	public class AlignmentColumn
	{
		HashMap <Pyrotag, Integer> obs;
		char value;
		AlignmentColumn child;
		AlignmentColumn parent;
		int flowNumber;

		AlignmentColumn [] insertionsAfter;

		public AlignmentColumn(char value)
		{
			this.value = value;
			this.obs = new HashMap <Pyrotag, Integer>();
			this.parent = null;
			this.child = null;
			this.insertionsAfter = new AlignmentColumn []{null,null,null}; //will only accept an insertion of another base
			this.flowNumber = -1;
		}

		public AlignmentColumn cloneRecursivelyWithTags(HashSet<Pyrotag> pToKeep, AlignmentColumn newParent) 
		{
			AlignmentColumn ac = new AlignmentColumn(this.value);
			ac.parent = newParent;

			if(newParent != null)
				newParent.child = ac;

			for(Pyrotag p : this.obs.keySet())
			{
				if(pToKeep.contains(p))
				{
					ac.obs.put(p, this.obs.get(p));
				}
			}

			ac.flowNumber = this.flowNumber;

			for(int i = 0; i < this.insertionsAfter.length; i++)
			{
				if(this.insertionsAfter[i] != null)
				{
					//f(ofInterest != null)
					//	System.out.print("I:");
					ac.insertionsAfter[i] = this.insertionsAfter[i].cloneWithTags(pToKeep);
				}
			}

			if(child != null)
			{
				this.child.cloneRecursivelyWithTags(pToKeep, ac);
			}
			
			return ac;
		}

		public AlignmentColumn cloneWithTags(HashSet <Pyrotag> pToKeep)
		{
			AlignmentColumn ac = new AlignmentColumn(this.value);
			for(Pyrotag p : this.obs.keySet())
			{
				if(pToKeep.contains(p))
				{
					ac.obs.put(p, this.obs.get(p));
				}
			}
			return ac;
		}


		public AlignmentColumn nextInsertionGivenLastFlow(char lastFlow)
		{
			char curr = lastFlow;
			do
			{
				for(int i = 0; i < insertionsAfter.length; i++)
				{
					if(insertionsAfter[i] != null && insertionsAfter[i].value == curr)
					{
						return insertionsAfter[i];
					}	
				}

				curr = Pyrotag.flowCycle.get(curr); //moves forward
			}while(curr != lastFlow);

			return null;
		}


		public void setFlowNumber(int flowNumber)
		{
			this.flowNumber = flowNumber;
		}

		public Set <Pyrotag> getTags() 
		{
			return this.obs.keySet();
		}

		public Set <Pyrotag> getInsertionTags()
		{
			HashSet <Pyrotag> insertTags = new HashSet <Pyrotag>();

			for(int i = 0; i < this.insertionsAfter.length; i++)
			{
				if(this.insertionsAfter[i] != null)
				{
					for(Pyrotag p: this.insertionsAfter[i].obs.keySet())
					{
						insertTags.add(p);
					}
				}
			}
			return insertTags;
		}

		public void setParent(AlignmentColumn newParent)
		{
			this.parent = newParent;
		}

		public AlignmentColumn getParent()
		{
			return this.parent;
		}

		public void setChild(AlignmentColumn newChild)
		{
			this.child = newChild;
		}

		public void addInserted(AlignmentColumn insertionAfterThis) throws Exception
		{
			for(int i = 0; i < this.insertionsAfter.length; i++)
			{
				if(this.insertionsAfter[i] == null)
				{
					this.insertionsAfter[i] = insertionAfterThis;
					return;
				}
			}

			throw new Exception("Node could not be added");
		}

		public AlignmentColumn getInsertionCorrespondingTo(char c)
		{
			for(int i = 0; i < this.insertionsAfter.length; i++)
			{
				if(this.insertionsAfter[i]!= null && this.insertionsAfter[i].value == c)
					return this.insertionsAfter[i];
			}
			return null;
		}

		public AlignmentColumn getChild()
		{
			return this.child;
		}

		public char getValue()
		{
			return this.value;
		}

		public HashMap <Pyrotag, Integer> getObservations()
		{
			return this.obs;
		}

		public String toString()
		{
			StringBuilder bd = new StringBuilder();
			bd.append("[");
			bd.append(this.value);
			bd.append(":");

			HashMap <Integer, HashSet <Pyrotag>> lengthToFreq = this.getHPLengthToTags();
			for(int length: lengthToFreq.keySet())
			{
				int freq = lengthToFreq.get(length).size();				
				bd.append(freq);
				bd.append("@");
				bd.append(length);
				bd.append(",");		
			}		

			bd.deleteCharAt(bd.length() - 1);


			bd.append("<");
			boolean insertExists =false;
			for(int i = 0; i < this.insertionsAfter.length; i++)
			{
				if(this.insertionsAfter[i] != null)
				{
					bd.append(this.insertionsAfter[i].toString());
					insertExists = true;
				}
			}

			if(!insertExists)
			{
				bd.deleteCharAt(bd.length() - 1);
			}
			else
			{
				bd.append(">");
			}
			bd.append("]");

			return bd.toString();
		}

		public HashMap <Integer, HashSet <Pyrotag>> getHPLengthToTags()
		{
			HashMap <Integer, HashSet <Pyrotag>> lengthToFreq = new HashMap <Integer, HashSet <Pyrotag>>();

			for(Pyrotag p: this.obs.keySet())
			{
				Integer length = this.obs.get(p);

				if(! lengthToFreq.containsKey(length))
				{
					lengthToFreq.put(length, new HashSet <Pyrotag>());
				}

				lengthToFreq.get(length).add(p);
			}		
			return lengthToFreq;
		}

		public void recordZeroForInsertionsBefore(Pyrotag toAdd) 
		{
			AlignmentColumn parent = this.getParent();

			if(parent != null)
			{
				for(int i = 0; i < parent.insertionsAfter.length; i++)
				{
					if(parent.insertionsAfter[i] != null)
					{
						if(!parent.insertionsAfter[i].obs.containsKey(toAdd)) //dont replace the observation!
							parent.insertionsAfter[i].obs.put(toAdd, 0);
					}
				}
			}
		}

		//try to avoid recursion, could be the reason for the lag.
		//boolean tells you if the job is complete.
		public boolean correctRead(Pyrotag p, StringBuilder construction, MutableInteger position, MutableInteger numModifications) 
		{
			char [] pStr = p.getCollapsedRead();

			if(this.value == ' ')
			{
				return false; //TODO: head of the node... might want to have errors as well....
			}
			else if(position.value() >= pStr.length) //dont want to go longer than the read is
			{
				return true; 
			}
			else
			{
				char curr = pStr[position.value()];

				int modeObs = -1;
				int modeLength = -1;

				HashMap <Integer, HashSet <Pyrotag>> freq = this.getHPLengthToTags();

				int tagObsLength = -1;

				for(Integer length: freq.keySet())
				{
					if(freq.get(length).size() > modeObs)
					{
						modeLength = length;
						modeObs = freq.get(length).size();
					}

					if(freq.get(length).contains(p))
					{
						tagObsLength  = length;
					}
				}

				if(tagObsLength != modeLength)
				{
					numModifications.increment();
				}

				for(int i = 0; i < modeLength; i++)
				{	
					construction.append(curr);
				}

				if(modeLength > 0) //takes care of those one-base insertions
					position.increment();

				for(int i = 0; i < this.insertionsAfter.length; i++)
				{
					if(this.insertionsAfter[i] != null)
					{
						this.insertionsAfter[i].correctRead(p, construction, position, numModifications); //will return because they have no children.
					}
				}
				return false;
			}
		}
	}
	
	public interface PendingChange
	{
		boolean performModification();
	}
	
	private class InsertAChild implements PendingChange
	{
		AlignmentColumn beforeInsertion;
		Pyrotag p;
		char insertedChar;
		int obsLength;
		ThreadedAlignment ta;
		
		public InsertAChild(ThreadedAlignment ta, AlignmentColumn beforeInsertion, Pyrotag p, char insertedChar, int obsLength)
		{
			this.beforeInsertion = beforeInsertion;
			this.p = p;
			this.insertedChar = insertedChar;
			this.obsLength = obsLength;
			this.ta = ta;
		}

		public boolean performModification() 
		{
			try
			{
				//perform all the stuff required to do an insertion node.

				AlignmentColumn insertionInQuery = new AlignmentColumn(insertedChar);
				HashSet <Pyrotag> allTags = ta.getAllTags();
			
				for(Pyrotag noInsert: allTags)
				{
					insertionInQuery.obs.put(noInsert, 0);
				}
				
				insertionInQuery.obs.put(p, this.obsLength);
				beforeInsertion.addInserted(insertionInQuery);
				
			}
			catch(Exception e)
			{
				
			}
			return false;
		}
	}
	
	private class AddObservation implements PendingChange
	{
		AlignmentColumn toUpdate;
		Pyrotag toAdd;
		int obsLength;
		
		public AddObservation(AlignmentColumn toUpdate, Pyrotag toAdd, int obsLength)
		{
			this.toUpdate = toUpdate;
			this.toAdd = toAdd;
			this.obsLength = obsLength;
		}
		
		public boolean performModification() 
		{
			try
			{
				this.toUpdate.obs.put(toAdd, obsLength);
				
				this.toUpdate.recordZeroForInsertionsBefore(toAdd);
				
				return true;
			}
			catch(Exception e)
			{	
			}
			return false;
		}
	}
	
	public Iterator <AlignmentColumn> iterator()
	{
		return new AlignmentIterator(this);
	}
	
	private class AlignmentIterator implements Iterator <AlignmentColumn>
	{
		private AlignmentColumn curr;
		
		public AlignmentIterator(ThreadedAlignment ta)
		{
			this.curr = ta.head;
		}
		
		public boolean hasNext() 
		{
			if(curr.getChild() != null)
				return true;
			return false;
		}

		//completely skip the head node in here.
		public AlignmentColumn next() 
		{
			this.curr = curr.getChild();
			return curr;
		}

		public void remove() 
		{
			//I do nothing.
		}
	}

	public LinkedList<ThreadedAlignment> splitNonConforming(HashSet<HashSet<Pyrotag>> nonConforming) 
	{
		LinkedList <ThreadedAlignment> newAligns = new LinkedList <ThreadedAlignment>();
		
		for(HashSet <Pyrotag> tagSet : nonConforming)
		{
				newAligns.add( this.cloneAlignmentWithTags(tagSet));
		}
		
		return newAligns;
	}

	public Pair <String, Integer> correctRead(Pyrotag p) 
	{
		StringBuilder construction = new StringBuilder();
		MutableInteger position = new MutableInteger(0);
		MutableInteger numModifications = new MutableInteger(0);	
		AlignmentColumn curr = head; //no recursion
		
		while(curr != null)
		{
			curr.correctRead(p, construction, position, numModifications);
			curr = curr.child;
		}
		
		return new Pair <String, Integer> (construction.toString(), numModifications.value());
	}
}
