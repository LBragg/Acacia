/*
 * Acacia - GS-FLX & Titanium read error-correction and de-replication software.
 * Copyright (C) <2011>  <Lauren Bragg and Glenn Stone - CSIRO CMIS & University of Queensland>
 * 
 * 	This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package pyromaniac.IO;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;

import pyromaniac.DataStructures.Pyrotag;
import pyromaniac.DataStructures.Sequence;
import pyromaniac.IO.SeqReadingUtility.SeqFormattingException;

public class FASTAImporter implements TagImporter
{
	//changing them from buffered reader to random access files!
	
	
	private SeqReadingUtility util;
	private FileReader seqIn;
	private FileReader qualIn;
	private RandomAccessFile ramSeq;
	private RandomAccessFile ramQual;
	private RandomAccessFile seq;
	private RandomAccessFile qual;
	private String seqFile;
	private String qualFile;
	private long [] seqStarts; //populate these first
	private long [] qualStarts;//populate these first
	
	public FASTAImporter(SeqReadingUtility util, String seqFile, String qualFile) throws IOException, FASTALoadingException
	{
		this.util = util;
	
		assert(seqFile != null);
		this.seqFile = seqFile;
		this.qualFile = qualFile;

		this.seqIn = new FileReader(seqFile);
		this.seq = new RandomAccessFile(seqFile,"r");

		if(qualFile != null)
		{
			this.qualIn = new FileReader(qualFile);
			this.qual = new RandomAccessFile(qualFile, "r");
		}

		this.init(); //know where each seq starts after this!
	}
	
///this idea isn't working so well.
	private void init() throws IOException, FASTALoadingException
	{
		ArrayList<Long> seqStartsL = new ArrayList <Long>();
		ArrayList<Long> qualStartsL = new ArrayList <Long>();

		while(this.hasNextPyrotag())
		{
			seqStartsL.add(this.seq.getFilePointer());
			Pyrotag p = this.getNextPyrotag();
			if(this.qual != null)
			{
				qualStartsL.add(this.qual.getFilePointer());
			}
		}

		this.seqStarts = new long [seqStartsL.size()];

		if(this.qual != null)
			this.qualStarts = new long [qualStartsL.size()];

		for(int i = 0; i < seqStarts.length; i++)
		{
			seqStarts[i] = seqStartsL.get(i);

			if(this.qual != null)
				qualStarts[i] = qualStartsL.get(i);
		}

		this.seq.seek(0);
		if(qual != null)
			this.qual.seek(0);

	}
	
	public pyromaniac.DataStructures.Pyrotag getNextPyrotag() throws FASTALoadingException
	{	
		if((this.qual == null || util.hasNextQualitySeq(this.qual, this.qualFile)))
		{
			Sequence <Character> nucleotides = this.util.getNextSeq(this.seq, this.seqFile);
			
			if(nucleotides == null)
			{
				System.out.println("Util returned null nucleotides");
			}
			
			Sequence <Integer> qualities = null;
			if(this.qual != null)
			{
				qualities = this.util.getNextQualitySeq(this.qual, this.qualFile);
			}
			
			if(qualities == null || nucleotides.getId().equals(qualities.getId()))
			{
				return new Pyrotag(nucleotides.getId(), nucleotides.getDesc(), nucleotides, qualities);
			}
			else
			{
				throw new FASTALoadingException("Sequence ID " + nucleotides.getId() + 
							" does not match corresponding quality entry " + qualities.getId(), this.seqFile);
			}
		}
		
		return null;
	}
	
	public boolean hasNextPyrotag()
	{
		if(util.hasNextSeq(this.seq, this.seqFile) && (this.qual == null || util.hasNextQualitySeq(this.qual, this.qualFile)))
		{
			return true;
		}

		return false;
	}
	
	public class FASTALoadingException extends TagImporter.ImportException
	{
		private static final long serialVersionUID = 1L;
		public FASTALoadingException(String message, String filename)
		{
			super("File: " + filename  + " FASTALoadingException: " + message);
		}
	}

	public void closeFiles() 
	{
		try
		{
			if(this.seq != null)
			{
				this.seq.close();
			}
			
			if(this.qual != null)
			{
				this.qual.close();
			}
		}
		catch(IOException ie)
		{
			ie.printStackTrace();
		}
	}

	public pyromaniac.DataStructures.Pyrotag getPyrotagAtIndex(int index) 
	{
		try
		{
			long currPosSeq = seq.getFilePointer();
			long currPosQual = 0;
		
			if(qual != null)
				currPosQual = qual.getFilePointer();
		
			
			if(index > 0 && index < this.seqStarts.length)
			{
				this.seq.seek(seqStarts[index]);
				if(qual != null)
					this.qual.seek(qualStarts[index]);
				Pyrotag p = this.getNextPyrotag();
				this.seq.seek(currPosSeq);
				
				if(this.qual != null)
					this.qual.seek(currPosQual);
				return p;
				
			}
		}
		catch(IOException ie)
		{
			
		} catch (FASTALoadingException e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
}
